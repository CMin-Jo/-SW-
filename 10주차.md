## LAB 

#### 9-1
```
print((200).__sub__(100))

print((200).__mul__(100))

print((200).__truediv__(100))


print([10,20,30,40].pop())

print(dir(int))
print(dir(list))
```
#### 9-2
```
1.다음 용어를 정의하여라
a)객체 지향 프로그래밍
프로그램을 짤 때, 프로그램을 실제 세상에 가깝게 모델링 하는 기법
b)절차적 프로그래밍
함수나 모듈을 만들어두고 이것들을 문제해결 순서에 맞게 호출하여 수행하는 기법
c)그래픽 사용자 인터페이스
컴퓨터와 상호 작용하여 다양한 작업과 프로세스를 수행하는 데 사용되는 시각적 인터페이스

2.객체 지향 프로그래밍 기법과 절차적 프로그래밍 기법의 차이점을 기술하여라.
객체 지향 프로그래밍은 말 그대로 객체를 생성해 field와 method를 생성하여 프로그래밍을 하는 기법이다.
절차적 프로그래밍 방식은 데이터들이 많아지고 함수가 많아진다면 매우 많은 호출이 필요하기에 대규모 프로젝트에서는 사용이 어렵다는 단점이 있다.
객체 지향 프로그래밍은 그 자체의 난이도가 높다는것이 단점이다.
```

#### 9-3
```
1.다음 용어를 정의하여라.
a)클래스
변수(데이터, 속성)와 메서드(행위)를 가지고 있는 집합이다.
b)객체
물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른것과 식별 가능한 것.
c)인스턴스
클래스로부터 객체를 선언하는 과정을 클래스의 인스턴스 화
또한, 이렇게 선언된 해당 클래스 타입의 객체를 인스턴스라고 함
d)클래스의 속성
객체, 요소, 또는 파일의 성질이다. field라고도 부른다
e)클래스의 동작
객체의 움직임이다. method라고도 부른다.
```

#### 9-4
```
class Dog:
    def bark(self):
        print("멍멍~~")


my_dog = Dog()
my_dog.bark()
```

#### 9-5
```
class Dog:
    def __init__(self, name):
        self.name = name
    def bark(self):
        print("멍멍~~")


my_dog = Dog('Jindo')
my_dog.bark()
```

#### 9-6
```
class Dog:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return 'Dog(name = ' + self.name + ')'


my_dog = Dog('Jindo')
print('my_dog의 정보 : ',end='')
print(my_dog)
```

#### 9-7
```
n = 100
m = 100

if n is m:
    print('n is m')
else:
    print('n is not m')
```

#### 9-8
```
class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __mul__(self, other):
        return Vector2D(self.x * other.x, self.y * other.y)
    def __truediv__(self, other):
        return Vector2D(self.x / other.x, self.y / other.y)
    def __neg__(self):
        return Vector2D(self.x * (-1), self.y * (-1))
    def __str__(self):
        return "("+str(self.x)+", "+str(self.y)+")"


v1 = Vector2D(30,40)
v2 = Vector2D(10,20)
print("v1 * v2 = ",end='')
print(v1.__mul__(v2).__str__())
print("v1 / v2 = ",end='')
print(v1.__truediv__(v2).__str__())
print("-v1 = ",end='')
print(v1.__neg__().__str__())
```

#### 9-9
```
class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __lt__(self, other):
        if self.x**2 + self.y **2 < other.x**2 + other.y **2:
            return True
        else:
            return False
    def __le__(self, other):
        if self.x**2 + self.y **2 <= other.x**2 + other.y **2:
            return True
        else:
            return False
    def __ge__(self, other):
        if self.x**2 + self.y **2 >= other.x**2 + other.y **2:
            return True
        else:
            return False
    def __gt__(self, other):
        if self.x**2 + self.y **2 > other.x**2 + other.y **2:
            return True
        else:
            return False



v1 = Vector2D(30,40)
v2 = Vector2D(10,20)
print("v1 > v2 = ",end='')
print(v1.__gt__(v2).__str__())
print("v1 >= v2 = ",end='')
print(v1.__ge__(v2).__str__())
print("v1 < v2 = ",end='')
print(v1.__lt__(v2).__str__())
print("v1 <= v2 = ",end='')
print(v1.__le__(v2).__str__())
```

